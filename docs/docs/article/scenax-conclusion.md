# 🏁 Заключение: почему `scenax` — это новый стандарт для API-тестов на Vitest

Восемь итераций. Каждая — шаг к читаемым, структурированным, декларативным тестам, где код становится сценарием, а сценарий — частью продукта.

Изначально мы просто хотели сделать DSL-обёртку над `vitest` и `allure-js`, чтобы улучшить читаемость и отчётность API-тестов. Но по пути мы пришли к **архитектурному паттерну**, которого… не существовало. Мы не нашли ни одного готового решения, которое:

- давало бы декларативный DSL для API-сценариев на TypeScript,
- строило бы тест-кейсы как классы с аннотированными шагами,
- автоматически генерировало бы Allure-отчёты без дублирования,
- масштабировалось бы по BDD-образцу, но без Gherkin.

Так родился **`scenax`** — не просто обёртка, а **отдельная архитектура** и **open-source DSL-фреймворк** для построения тестов нового поколения.

---

## 🧠 Что мы дали вместо "просто тестов"

| Было                                     | Стало                                      |
| ---------------------------------------- | ------------------------------------------ |
| `test(name, fn)`                         | `@TestCase()` — декларативное описание     |
| `await step('...', () => ...)`           | `@Step()` — переиспользуемые шаги          |
| `feature`, `label`, `severity` вручную   | `@Feature()`, `@Severity()` и т.д.         |
| Тест = одна функция                      | Тест = структура: сценарий + шаги + контекст |
| Документация отдельно                    | Читаемый тест = документация               |

---

## 🔥 Что даёт `scenax` прямо сейчас

- 🧩 Читаемые API-тесты, написанные как сценарии
- 🎯 Точная привязка к Allure TestOps: `allureId`, `severity`, `feature`
- 📦 Сценарные шаги (`@Step`, `@Scenario`, `runSteps()`)
- 🧠 Шаги с контекстом, передаваемым автоматически (`@Context()`)
- 🧪 Один DSL — один стиль — вся команда пишет одинаково

---

## 🤔 «Зачем классы? Все уходят в функции!»

Да, в UI-фреймворках функции вытеснили классы — там нужна реактивность, локальность и гибкость. Но в сценарном тестировании:

- Класс = сценарий (UseCase)
- Метод = шаг
- Декоратор = декларативное описание поведения
- Контекст и расширения интегрируются естественно

📌 Мы вдохновились Serenity, NestJS и Playwright, но собрали их лучшее — в class-based DSL на TypeScript. Архитектурно, гибко, читаемо.

---

## 📈 Сравнение с Vitest + Allure

| Параметр              | Vitest + Allure                   | `scenax`                                 |
|-----------------------|-----------------------------------|------------------------------------------|
| Параметризация        | ✅ `test.each`                    | ✅ `@TestCase.each()` + метаинфо         |
| Структура шагов       | ⚠️ вручную через `step()`         | ✅ `@Step()` + `runSteps()`              |
| Архитектура           | ⚠️ flat-функции                  | ✅ сценарии как классы                   |
| Контекст              | ❌ руками                        | ✅ через `@Context()`                    |
| Стиль                 | произвольный                     | единый DSL-стиль                        |
| Отчётность            | зависит от дисциплины            | встроена и стандартизирована             |

---

## 🧱 Что за паттерн мы реализовали?

`scenax` реализует архитектуру, которую мы называем **Scenario-oriented DSL**.

Вдохновлено:
- 🧠 **Serenity BDD** (Java): идея шагов и сценариев
- ⚙️ **NestJS**: классы, декораторы, DI
- 🧪 **Playwright**: изоляция, fixtures, контекст

Но объединено и упрощено для TypeScript-разработки:

- Сценарий = декларативный класс с мета-информацией
- Поведение = управляется методами + контекстом
- Шаги = аннотированные методы, которые легко вызывать
- Расширение = через слои, DI и классы без магии

📌 Мы не нашли ни одного аналога, который делал бы всё это **в одном DSL**.

---

## 🤝 Кто должен использовать это прямо сейчас

- Команды, которым **нужен читаемый Allure-отчёт**, а не набор `console.log`
- Команды, где **есть TestOps или QA**, которым нужен живой сценарий
- Архитекторы, которые устали от `copy-paste` шагов в тестах
- Разработчики, которым важно писать **чисто, предсказуемо и гибко**

---

## 🤖 Есть ли аналоги?

| Решение           | Язык  | Отличия                                                        |
|-------------------|--------|-----------------------------------------------------------------|
| Serenity BDD      | Java   | Сложный вход, громоздкая структура                             |
| Playwright test   | TS     | Фокус на UI, нет сценариев-классов                             |
| `vitest` + allure | TS     | Нет DSL, мета-инфо и автоматизации сценариев                   |
| ✅ `scenax`        | TS     | Простой DSL, шаги + сценарии, class-based архитектура          |

---

## 🚀 Потенциал развития

`scenax` — это не «утилита». Это **библиотека тестовой архитектуры**.

В будущем мы планируем:

- 🧱 `StepLibrary()` — lego-блоки шагов для переиспользования в сценариях
- 🧬 `@Inject()` для nested-инъекций и dependency tree
- 🧠 Интеграция с UI/Playwright тестами на том же DSL
- 📊 Авто-трекинг статистики шагов, сценариев и покрытия через Allure
- 🛠️ CLI и VS Code плагины для генерации шаблонов шагов
- 🧭 Архитектурные пресеты для монореп, микросервисов и CI-интеграций

---

## 💬 Заключительная мысль

> `scenax` — это когда API-тест превращается в **намерение**,  
> когда сценарий читается как **документация**,  
> и когда команда начинает говорить на **одном языке**.

Если вы устали от «тестов ради тестов»,  
если вам нужен **внятный отчёт, живой DSL и архитектура, которая масштабируется** —

**Добро пожаловать в `scenax`.**

🚀 Попробуй. Подключи. Покажи команде — и вы уже не вернётесь назад.

---

📦 GitHub: https://github.com/dmitry-nkt/scenax  
🧪 Документация: в каждом тесте  
👉 Установи: `npm i -D scenax`
